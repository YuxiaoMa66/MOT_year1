% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{article}
\usepackage{amsmath,amssymb}
\usepackage{lmodern}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  pdftitle={Workshop: An introduction to working with R},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage[margin=1in]{geometry}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.77,0.63,0.00}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi

\title{Workshop: An introduction to working with R}
\author{}
\date{\vspace{-2.5em}}

\begin{document}
\maketitle

\hypertarget{working-with-this-document}{%
\subsection{Working with this
document}\label{working-with-this-document}}

\hypertarget{setup-of-this-file}{%
\subsubsection{Setup of this file}\label{setup-of-this-file}}

You just opened an R workbook in the R Markdown format. This format
allows you to alternate between written text and (running) code (go to
\href{http://rmarkdown.rstudio.com}{this} page for more details on using
R Markdown). Whereas text is displayed as expected when using an
elementary text editor, the format utilises so-called `chunks' to show
and execute code. Below, you'll see an example of such a chunk:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{print}\NormalTok{(}\StringTok{"Hello, World!"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Hello, World!"
\end{verbatim}

On the upper right of each chunk, you see three options (position the
cursor over each icon and wait a bit for the tooltip to show):

\begin{itemize}
\tightlist
\item
  `Modify Chunk Options'

  \begin{itemize}
  \tightlist
  \item
    This option allows you to control the appearance and behaviour of
    each chunk. For example, you can change its name or adjust its
    output options. In this tutorial series, there is \textbf{no} need
    to adjust these options.
  \end{itemize}
\item
  `Run All Chunks Above'

  \begin{itemize}
  \tightlist
  \item
    Clicking this option makes that R executes all previous code chunks,
    which makes it helpful if you made it halfway through a tutorial and
    need to stop and resume it later. \textbf{Because chunks tend to be
    cumulative (i.e.~they could use output generated in previous ones),
    it's pivotal that you run all chunks before the point where you want
    to resume}.
  \end{itemize}
\item
  `Run Current Chunk'

  \begin{itemize}
  \tightlist
  \item
    Clicking this option executes a chunk's code. You can use this
    option as you proceed through the tutorial. Please try running the
    code chunk above now.
  \end{itemize}
\end{itemize}

In addition to the options for each chunk, you'll find the `Run'-drop
down menu. A useful command in this menu is `Run Selected Line(s)'. This
command allows you to run code in chunks on a line-by-line basis. It
comes in handy when learning the basics, so we strongly recommend using
this command (and its shortcut)! The `Run'-drop down menu also contains
other more sophisticated options. Explore them, and see if they offer
additional value to the already discussed ones. Lastly, note the two
buttons on the upper-left of this notebook: `Source' and `Visual'.
`Source' mode displays this workbook in its markup language. `Visual'
mode shows this workbook in the form that, more or less, results when
you export (``knit'') the document to an output format such as .html or
.pdf. It is up to you to decide which mode you prefer.

\hypertarget{r-workbooks-versus-r-scripts-and-a-note-on-the-working-directory}{%
\subsubsection{R Workbooks versus R Scripts and a note on the working
directory}\label{r-workbooks-versus-r-scripts-and-a-note-on-the-working-directory}}

The current workbook is helpful when you want to write, e.g.~a document
in which you wish to integrate reporting and analysis components. This
approach strongly resonates with the reproducible research philosophy
that has emerged in recent years. Because of this, we ask you to write
your final report in an R Workbook. When you work on developing specific
parts of code, this workbook setup might distract or work
counterproductive. If this applies to you, be advised that you can also
maintain one or more R-scripts where you do the code work (go to `File'
--\textgreater{} `New File' --\textgreater{} `R Script'). However, you
must transfer the developed code to a workbook to integrate it with your
report.

If you decide to do your coding work in separate scripts first, then it
is necessary to set your working directory. You can do this with the
\texttt{setwd()} command. This command tells R which folder to use for
reading and writing data. The abbreviation \texttt{wd} stands for
`working directory'. It's comparable to, e.g.~selecting the folder where
a .docx-document is stored that you want to open when working in Word.
Whereas in an R Workbook, this working directory is the directory from
which it loads the workbook, it needs to be specified explicitly when
not working from a workbook. If, for example, you have set `Users' as a
top-level folder, then the command would read
\texttt{setwd("C:/Users")}. Regardless of the operating system you are
working with, you \textbf{must always use forward slashes} (`/') when
specifying the path name. Using a forward slash is the default on Mac
systems but \textbf{not} Windows systems (which use `\textbackslash{}').
Also note that if you work on a Mac, we don't specify the hard drive in
the working directory (so the \texttt{setwd()} command on a Mac would
read as \texttt{setwd("/Users")}). Selecting which folder to use as your
working directory depends on your preferences for organising your hard
drive, so we won't dictate which folder to use.

\hypertarget{proceeding-through-the-tutorial}{%
\subsubsection{Proceeding through the
tutorial}\label{proceeding-through-the-tutorial}}

This tutorial consists of two main parts: (1) An introduction to the
tutorial's objectives and (2) An introduction to working with R. Work
your way through both parts. In this tutorial, we won't ask you to
change the code yourself. In later tutorials, we will, and doing so is
pivotal for all code to run. It is therefore strongly advised to try to
make minor modifications to the code we provide to understand what it
does. We will invite you to do so at several points throughout this
tutorial. You can click the Knit button above once you have made it to
the tutorial's end. Clicking this button generates an HTML document that
includes this tutorial's content and the output of the code chunks.

\hypertarget{tutorial-introduction-objectives-and-some-considerations}{%
\subsection{Tutorial introduction: Objectives and some
considerations}\label{tutorial-introduction-objectives-and-some-considerations}}

\hypertarget{objectives}{%
\subsubsection{Objectives}\label{objectives}}

If you made it up to this point, you successfully installed R, RStudio
and opened this workbook. Congratulations! This workbook aims to
acquaint you with several fundamental R data operations. More
specifically, after having followed this tutorial, you will be able to
do the following using RStudio:

\begin{itemize}
\item
  Work with and explore vectors
\item
  Work with and explore data frames
\item
  Engage in several data-wrangling activities (i.e.~creating, loading,
  combining and modifying data)
\item
  Use functions available through base r
\end{itemize}

\hypertarget{some-considerations-before-you-begin}{%
\subsubsection{Some considerations before you
begin}\label{some-considerations-before-you-begin}}

Learning how to code can be intimidating, especially in an environment
as unforgiving as R. Believe us, we've been there (if you are
interested, ask us for the juicy details)! This workbook format offers a
relatively friendly way to get acquainted with coding without becoming a
full-fledged programmer. The main goal is to get acquainted with R. In
the quiz that you will take based on this workbook, we therefore won't
ask you to write or adjust code. In subsequent quizzes we will, but in
the first quiz we will test your understanding of the different aspects
covered in this workbook.

In the end, we offer solutions to problems you are likely to encounter
in the future. As such, the code in this workbook serves as a basic
repertoire you can later re-use and adjust as you see fit. Once you are
at that point, realise that for many tasks in R, there is more than one
way to do it. Purists will say there are good and bad ways of doing
things, but first, focus on achieving whatever you want to get done.
Refinement and striving for perfection come later, if ever.

Do try, however, to understand what is happening in each step. And: do
\textbf{not} be afraid to break things (this is easy to do in R in any
case). In fact: make it your goal to break things to see how they work!
Playing around with the code will deepen your understanding of R. In
that sense, adopting a `frob, twiddle and tweak'-mindset can be helpful.
According to Eric S. Raymond, software developer and author of
\href{https://www.gutenberg.org/files/3008/3008-h/3008-h.htm}{The New
Hacker's Dictionary}, these terms relate to different levels of
manipulation of an unknown device to understand what it does. `Frob'
refers to aimless manipulation (moving parts very broadly to identify
their functions/range, also known as destructive testing), ``twiddle''
refers to gross manipulation (moving parts in smaller ways, usually one
at a time, to estimate likely settings), and ``tweak'' refers to
fine-tuning (make fine adjustments, typically related to one another, to
come to a final configuration). If you get stuck (and believe us, this
will happen less often than you might think), you can always start anew
with a clean notebook.

We show how to code in base R in this tutorial. If you are familiar with
working with R, you might wonder why we don't use the functionality
offered by the packages bundled in the
\href{https://www.tidyverse.org}{tidyverse}. Our answer to that question
would be to exercise patience. The tidyverse is great, but let's first
learn the basics. To use an (exaggerated) music analogy: learning base R
is like practising scales when you learn how to play the keyboard.
Starting with the tidyverse packages right away is like pressing the
demo button on that keyboard and thinking that is all there is to it. At
this point, however, it is too early to have this discussion. However,
if you are interested in it, read more about it
\href{https://github.com/matloff/TidyverseSkeptic}{here}.

\hypertarget{tutorial-walkthrough}{%
\subsection{Tutorial walkthrough}\label{tutorial-walkthrough}}

\hypertarget{working-with-vectors}{%
\subsubsection{1. Working with vectors}\label{working-with-vectors}}

\hypertarget{numeric-vectors}{%
\paragraph{Numeric vectors}\label{numeric-vectors}}

Let's start with creating a numeric vector (click ``Run Current Chunk''
in the below code chunk):

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 2 3 4
\end{verbatim}

In the above, we embed a four-number sequence in the \texttt{c()}
function. This function concatenates (or combines, hence the c) the
numbers we have fed to it. Using the \texttt{c()} function often is
necessary (it is required above: try entering \texttt{1,\ 2,\ 3,\ 4}
instead and see what happens). But: it never hurts to use it. We
recommend using it whenever possible to avoid bugs in your code that are
difficult to trace. Note that entering the vector does nothing more than
printing it (see also the lower left part of RStudio, tab `Console').
What we typically want to do instead is to assign this vector to a named
object, for example, \texttt{x}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Now, R doesn't print anything to the console. In general, if we want to
see what an object looks like, we can call it:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 2 3 4
\end{verbatim}

Alternatively, you could use the \texttt{print} command, so
\texttt{print(x)}. Try this yourself by changing the code in the chunk
above. In the subsequent code chunks, we often run code and explicitly
call the result. This approach is not a default thing to do in R, but we
do it here to show the outcome of an operation for educational purposes.

Note that vector \texttt{x}, once created, becomes visible in the upper
right part of RStudio (see tab `Environment'). Creating a vector like
this is easy when you have a few numbers, but this is a cumbersome
approach when you want to make larger ones, for example, a sequence from
1 to 25. Indeed, manually entering each number one by one is different
from what programming life should be (as a general rule, whenever you
feel you are doing something very inefficient, you are right, and there
is probably a better way to do it). In the case of creating a vector
from 1 to 25, we can use the colon sign:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{25}\NormalTok{)}
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
\end{verbatim}

We assigned a new vector to an existing object, and R overwrote that
object without warning. In the current example, this is okay, but you
can imagine this sometimes is the case, so be mindful of this. A
powerful feature distinguishing R from other languages is called
`vectorisation'. Vectorisation means that an operator or function will
act on each vector element. Wait, what? An example says more than a
thousand words here, so say we want to multiply each element of our
vector \texttt{x} by 2. One way to do this is to write a loop:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \FunctionTok{seq}\NormalTok{(}\FunctionTok{length}\NormalTok{(x))) \{}
\NormalTok{    x[i] }\OtherTok{\textless{}{-}}\NormalTok{ x[i] }\SpecialCharTok{*} \DecValTok{2}
\NormalTok{\}}
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1]  2  4  6  8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 46 48 50
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{25}\NormalTok{) }\CommentTok{\# initialize x to its default values}
\end{Highlighting}
\end{Shaded}

The loop above iterates through each element (i) of x, multiplies it by
two and overwrites it with the result of the multiplication (you can
ignore the last line. We reset x to its starting state. Like printing
objects, this is not a default thing to do in R but we do it here for
the sake of explanation). Loops are generally convenient for
understanding what happens in a particular step in your code. Loops,
however, are also considered inefficient. Use them if you want, but be
prepared. You will get criticised by ``the puRists'' (e.g.~when asking
for help on an online forum. Also, see Circle 3 of the
\href{https://www.burns-stat.com/pages/Tutor/R_inferno.pdf}{R Inferno}).
This point in the tutorial may be a good moment to expand on our earlier
statement: focus on achieving what you want to achieve, \textbf{but}
keep your code simple. In the specific example above, vectorisation
cancels the need for a loop. Instead of this loop, we can multiply x by
2:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}}\NormalTok{ x }\SpecialCharTok{*} \DecValTok{2}
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1]  2  4  6  8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 46 48 50
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{25}\NormalTok{) }\CommentTok{\# initialize x to its default values}
\end{Highlighting}
\end{Shaded}

In this example, the multiplication operator (\texttt{*}) operates on
each element of x at once. As said, this also holds for functions, for
example, when we want to check the length of each element of \texttt{x}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{nchar}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
\end{verbatim}

Also, note that we use the \texttt{\#}-sign in some chunks above. This
sign tells R to ignore all text that comes after it and hence can be
used to comment out specific lines of code (for example, when you are
developing or debugging code) or to explain what a particular part in
your code does. Our advice is to comment generously on your code.
Commenting helps others to make sense of what happens. An important
thing to realise here is that the future you (e.g.~you in two or three
weeks) also belongs to that group of others: it is natural (and we also
believe it to be healthy) to forget about the specifics of a piece of
code once you got it running, and then it is helpful to have a pointer
about what it does should there be a need to go back to it the future
(e.g.~for unexpected debugging or further development).

We conclude this explanation of working with numeric vectors with an
example that shows you can use existing vectors to create new ones. In
the example below, we add vector \texttt{x} to two times vector
\texttt{x} and assign the result to a new object \texttt{y}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y }\OtherTok{\textless{}{-}}\NormalTok{ x }\SpecialCharTok{+} \DecValTok{2}\SpecialCharTok{*}\NormalTok{x}
\NormalTok{y}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1]  3  6  9 12 15 18 21 24 27 30 33 36 39 42 45 48 51 54 57 60 63 66 69 72 75
\end{verbatim}

\hypertarget{character-vectors}{%
\paragraph{Character vectors}\label{character-vectors}}

So far, we have focused on numeric vectors. But vectors can also contain
other data types, such as characters (e.g.~words). Such a vector could
look like this (note the quotation marks):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{words }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"R"}\NormalTok{, }\StringTok{"is"}\NormalTok{, }\StringTok{"awesome"}\NormalTok{)}
\NormalTok{words}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "R"       "is"      "awesome"
\end{verbatim}

Many functions that apply to numeric vectors can also work with
character vectors, such as \texttt{length}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{length}\NormalTok{(words)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3
\end{verbatim}

An important thing to know is that vectors may only contain elements
that belong to the same class (e.g.~character or numeric). Let's see
what happens if we add the number 4 to our words object:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{words }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"R"}\NormalTok{, }\StringTok{"is"}\NormalTok{, }\StringTok{"awesome"}\NormalTok{, }\DecValTok{4}\NormalTok{)}
\NormalTok{words}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "R"       "is"      "awesome" "4"
\end{verbatim}

As you see, R happily accepts the number but treats it as if it were a
character (R displays the number between parentheses, just like the
words). Indeed, if we want to multiply this fourth element by two (more
about subsetting later), R throws an error:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{words[}\DecValTok{4}\NormalTok{] }\SpecialCharTok{*} \DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Error in words[4] * 2: 二进列运算符中有非数值参数
\end{verbatim}

This point in the tutorial is an appropriate moment to say a thing or
two about the anatomy of code chunks. Each chunk starts with text
enclosed by curly braces (\texttt{\{\}}). This part allows you to
exercise control over the output of each chunk. For example, we have set
the chunk option \texttt{error\ =\ TRUE} in the chunk above. The default
in RStudio is that mistakes in code chunks will halt R
(i.e.~\texttt{error\ =\ FALSE}, which R does not explicitly show because
it is the default). If (for example, for educational purposes, like in
this workbook) we want to show errors without halting R, we must change
this default.

Another setting that is not mandatory but comes in handy is the chunk
label. This label is the text string that comes (and always should come)
immediately after the name of the environment in which you want the code
to be executed (which is always \texttt{r} in this tutorial, but in
principle, nothing stops us from running code in other environments, for
example, Python). Using chunk labels is handy as this allows us to refer
to them in case of questions easily. Do note, however, that chunk names
should be unique!

Anyway, back to our character vector. When we check the class of the
words object or the class of its fourth element, we see that it is a
character:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(words)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "character"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{class}\NormalTok{(words[}\DecValTok{4}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "character"
\end{verbatim}

If you want to coerce the fourth element to a number, feed it to the
\texttt{as.numeric()} function and multiply its results by two (see
below). But typically, whenever you encounter a vector containing mixed
data types (all coerced to the same, most basic data type such as
\texttt{character} in the example we are currently looking at), you
probably have some additional data cleaning work to do. It is helpful to
know, however, that functions exist that can change the data type of
objects or their constituents, such as \texttt{as.numeric()}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{as.numeric}\NormalTok{(words[}\DecValTok{4}\NormalTok{]) }\SpecialCharTok{*} \DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 8
\end{verbatim}

\hypertarget{subsetting-vectors}{%
\paragraph{Subsetting vectors}\label{subsetting-vectors}}

Often, we want to subset vectors to extract specific values. For
example, let's say we want to know what the 5th element is of x. We can
do this by using square brackets:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[}\DecValTok{5}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 5
\end{verbatim}

In addition to looking at individual elements, we can select ranges, for
example, the 5th until the 10th element of x. To do this, we use a
vector, c(5:10), to subset another vector x:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[ }\FunctionTok{c}\NormalTok{(}\DecValTok{5}\SpecialCharTok{:}\DecValTok{10}\NormalTok{) ]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  5  6  7  8  9 10
\end{verbatim}

In the example above, the spaces between the square brackets and their
contents only enhance readability. We like our code to look spacious,
but you are free to choose your style. In the supplementary materials to
this tutorial, though, we will provide a link to a webpage that suggests
some coding hygiene principles.

Sub-setting data is also possible using logical constants. Again, one
example says more than a thousand words. Let's say we only want to
display those values in x that can be divided by four. We can use the
\%\%-operator, which gives us the modulus (or: the remainder from
division). Let's do this step-by-step, so you'll follow along. First, we
calculate the result of x modulus 4:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\SpecialCharTok{\%\%} \DecValTok{4}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] 1 2 3 0 1 2 3 0 1 2 3 0 1 2 3 0 1 2 3 0 1 2 3 0 1
\end{verbatim}

The result is a vector alternating between the 1, 2, 3, 0 - sequence.
Ten modulus four, for example, is two, as four goes into ten twice, and
then the remaining difference two is left over. Let's now create a
vector with logical constants that shows TRUE when the modulus equals
zero and FALSE when the modulus does not:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\SpecialCharTok{\%\%} \DecValTok{4} \SpecialCharTok{==} \DecValTok{0}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE
## [13] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE
## [25] FALSE
\end{verbatim}

The result of this step is another vector that we use to subset our
vector x:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x [ x }\SpecialCharTok{\%\%} \DecValTok{4} \SpecialCharTok{==} \DecValTok{0}\NormalTok{ ]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  4  8 12 16 20 24
\end{verbatim}

Ta-da! You just subsetted a vector using the result of an evaluation of
whether or not the output of an expression was 0. Most of the time,
subsetting is done like this to make your code more robust: instead of
hard-coding the elements (as in the c(5:10)-example), we filter based on
whether or not a particular condition is satisfied.

A last helpful trick to know is using the negative (\texttt{-}) sign
when subsetting. With this sign, we indicate which elements we do
\textbf{not} want to see instead of those we want. Sometimes, this makes
your code easier to read. For example, if we wish to see all elements of
x except the fifth one, we could do the following:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x [ }\SpecialCharTok{{-}}\DecValTok{5}\NormalTok{ ]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1]  1  2  3  4  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
\end{verbatim}

\hypertarget{concluding-remarks-on-vectors}{%
\paragraph{Concluding remarks on
vectors}\label{concluding-remarks-on-vectors}}

To conclude this part on vectors, it is good to know that vectors are
one of the fundamental building blocks for working with R. Not only do
we use them to store data, but we also use them for, e.g.~subsetting, or
iterating through data. They are so omnipresent in R that it would be
futile to devise a list of usage examples. This omnipresence also means
that whenever you run into problems with your code, it is good to break
the problem down to the vector level. Don't worry if you need some time
to grasp the meaning of that statement. Your understanding will grow
with experience.

If vectors are one of the basic blocks, this also means there is more to
it. In the next section, we'll look at how to combine multiple vectors
into the data frame object. Whereas vectors are the building blocks,
data frames are the working horses for working with data in R. If you
are familiar with working in Excel, compare a data frame with a
worksheet in Excel. As you understand some basics by now, this
discussion will include more advanced code.

\hypertarget{data-frames-and-indexing}{%
\subsubsection{2. Data frames and
indexing}\label{data-frames-and-indexing}}

In business analytics, we typically work with data sets containing
information on multiple observation units (e.g.~individuals) and
attributes (e.g.~age and length). Let's say, for example, we are avid
fans of the Breaking Bad series and want to keep track of some features
of our favourite characters:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{breaking\_bad }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}\AttributeTok{main\_character =} \FunctionTok{c}\NormalTok{(}\StringTok{"Walt"}\NormalTok{, }\StringTok{"Todd"}\NormalTok{, }\StringTok{"Skyler"}\NormalTok{, }\StringTok{"Gus"}\NormalTok{, }\StringTok{"Lydia"}\NormalTok{, }\StringTok{"Jimmy"}\NormalTok{),}
                           \AttributeTok{first\_occurence =} \FunctionTok{c}\NormalTok{(}\StringTok{"S01E01"}\NormalTok{, }\StringTok{"S05E03"}\NormalTok{, }\StringTok{"S01E01"}\NormalTok{, }\StringTok{"S02E11"}\NormalTok{, }\StringTok{"S05E02"}\NormalTok{, }\StringTok{"S92E11"}\NormalTok{),}
                           \AttributeTok{actors\_yob =} \FunctionTok{c}\NormalTok{(}\DecValTok{1956}\NormalTok{, }\DecValTok{1988}\NormalTok{, }\DecValTok{1968}\NormalTok{, }\DecValTok{1958}\NormalTok{, }\DecValTok{1975}\NormalTok{, }\DecValTok{1962}\NormalTok{),}
                           \AttributeTok{sex =} \FunctionTok{c}\NormalTok{(}\ConstantTok{NA}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{))}
\FunctionTok{head}\NormalTok{(breaking\_bad)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   main_character first_occurence actors_yob sex
## 1           Walt          S01E01       1956  NA
## 2           Todd          S05E03       1988   1
## 3         Skyler          S01E01       1968   0
## 4            Gus          S02E11       1958   1
## 5          Lydia          S05E02       1975   0
## 6          Jimmy          S92E11       1962   1
\end{verbatim}

If you don't like these characters or Breaking Bad: feel free to change
the code chunk above as you please (Wikipedia is a rich source of
information! This could be a nice web scraping exercise but let's go
there later). In the code chunk above, we assign a data frame to an
object called \texttt{breaking\_bad}. We create this data frame with the
\texttt{data.frame} function, in which we assign four vectors:
main\_character, first\_occurence, actors\_yob (yob = year of birth) and
sex. Whereas the first two vectors are characters, the second two are
numeric vectors (with the last one being a special case containing dummy
scores, but we leave that point for now). For reasons that will become
clear later, we have assigned an \texttt{NA} value for Walt's sex.
\texttt{NA} stands for ``Not Available'' and is used in R to denote
missing values.

In contrast to the rather sterile object names we used when discussing
vectors, we now use labels that have substantive meaning. For the names
of the vectors, this is useful because these names end up being the
column names of the resulting data frame. For the name of that data
frame, using a mnemonic label helps us remember its contents. Using such
mnemonic labels for whatever object we create is generally good
practice. Compared to labels such as \texttt{x}, \texttt{data\_set} or
\texttt{result\_2a}, your code is easier to read and understand. Also,
note the use of underscores (\texttt{\_}). We strongly advise you to do
this as well, as R fares most well when it can work with objects
labelled with one uninterrupted string that does \textbf{not} contain
spaces. It also might work with labels that contain spaces
(e.g.~\texttt{main\ characters} instead of \texttt{main\_characters}).
But believe us: you want to spend your energy and time on something
other than the potential code-troubleshooting that stems from using
spaces.

The last command in the chunk above applies the \texttt{head} command to
the \texttt{breaking\_bad} data frame. By default, this command shows
the first six rows of the data frame fed to it. In this specific
example, the output shows the entire data frame because it only contains
six rows, but this is a useful function when you want to get an idea of
the content of larger data frames. The \texttt{head} command also
includes an option specifying the number of rows to display. We do
\textbf{not} demonstrate this in the chunk below. Instead, the chunk
shows how to get help when you want to know more about a function's
options: type a question mark (\texttt{?}) immediately followed by the
function's name. You'll then see that the help file of that function
shows in the lower right part of your console (tab `Help'). Please read
it, then try to modify the \texttt{head} function in the chunk above so
that it only displays the first two rows of the data frame. R help files
are notoriously cryptic, so sometimes it might work better if you look
for a function using a search engine. As a first step, however, it could
work.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{?head}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 打开httpd帮助服务器… 好了
\end{verbatim}

Although the \texttt{head} function is useful, its output gets messy
when applied to a data frame with multiple columns and rows. Instead, we
prefer using the \texttt{str()} function:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{str}\NormalTok{(breaking\_bad)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 'data.frame':    6 obs. of  4 variables:
##  $ main_character : chr  "Walt" "Todd" "Skyler" "Gus" ...
##  $ first_occurence: chr  "S01E01" "S05E03" "S01E01" "S02E11" ...
##  $ actors_yob     : num  1956 1988 1968 1958 1975 ...
##  $ sex            : num  NA 1 0 1 0 1
\end{verbatim}

Not only does this provide insight into the contents of a data frame,
but it also shows its dimensions (number of observations and variables)
and the data type of each vector it contains. This information helps you
to scan for things that need attention before working with the data
frame. For example, R guesses the data type of each vector. It succeeds
when the data type of a vector is unambiguous, but when you get
unexpected results, there might be an issue with the data you want to
address first. For example, we earlier sketched the situation where R
recognises a numeric variable as a character. In such a case, it could
be that one of the entries in the source vector might be non-numeric
(e.g.~``four'' instead of ``4''). This scenario could sound hypothetical
to you. Still, we must emphasise the need to perform sanity checks (is
whatever output I am looking at the output I expected?) whenever we can.
The cool thing about computers is that they can do a lot of tasks much
faster and more efficiently than human beings. The not-so-cool thing
about computers is that they do what you ask them to do. They don't ask
critical questions if you make mistakes in your question (i.e.~your
code) or the materials you provide (i.e.~the data). So stay on top of
it!

Another useful function to check your data and get some insight into it
is the \texttt{summary} function. R bases the output for each variable
on its data type (i.e.~character vs numeric):

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{summary}\NormalTok{(breaking\_bad)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  main_character     first_occurence      actors_yob        sex     
##  Length:6           Length:6           Min.   :1956   Min.   :0.0  
##  Class :character   Class :character   1st Qu.:1959   1st Qu.:0.0  
##  Mode  :character   Mode  :character   Median :1965   Median :1.0  
##                                        Mean   :1968   Mean   :0.6  
##                                        3rd Qu.:1973   3rd Qu.:1.0  
##                                        Max.   :1988   Max.   :1.0  
##                                                       NA's   :1
\end{verbatim}

From the above, you can deduce that the function provides little
information for character variables. To tackle this, you can use the
\texttt{table} function to generate an overview of such variables. This
function only works well when you have a few unique categories, so use
caution. We could, for example, check the frequencies of the
first\_occurence variable:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{table}\NormalTok{(breaking\_bad}\SpecialCharTok{$}\NormalTok{first\_occurence)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
## S01E01 S02E11 S05E02 S05E03 S92E11 
##      2      1      1      1      1
\end{verbatim}

\hypertarget{subsetting-data-frames}{%
\paragraph{Subsetting data frames}\label{subsetting-data-frames}}

If we return to the output of the \texttt{str()} function above, note
the dollar (\texttt{\$})-signs. Using this sign allows you to subset
specific columns of a data frame. For example, we can run the following
code if we want to see the names of the main characters:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{breaking\_bad}\SpecialCharTok{$}\NormalTok{main\_character}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Walt"   "Todd"   "Skyler" "Gus"    "Lydia"  "Jimmy"
\end{verbatim}

For those that cannot surrender to their urge for structure and order,
we could embed the command above in the \texttt{sort()} function so that
R automatically sorts the output for you (in this case, in alphabetical
order but also works for numbers):

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sort}\NormalTok{(breaking\_bad}\SpecialCharTok{$}\NormalTok{main\_character)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Gus"    "Jimmy"  "Lydia"  "Skyler" "Todd"   "Walt"
\end{verbatim}

And, of course, we can use the contents of a data frame in all types of
calculations. For example, when determining actors' current or average
age. Note that in the first line below, we embed the output of a
function, \texttt{Sys.Date()}, in another function, \texttt{format}, of
which the output, in turn, is embedded in yet another function. In the
second line, we even go further! Nesting functions often is possible,
but with an eye on the readability of your code, this is \textbf{not} a
good idea by default. We leave it up to you to develop your style in
this regard:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{as.numeric}\NormalTok{(}\FunctionTok{format}\NormalTok{(}\FunctionTok{Sys.Date}\NormalTok{(), }\StringTok{"\%Y"}\NormalTok{)) }\SpecialCharTok{{-}}\NormalTok{ breaking\_bad}\SpecialCharTok{$}\NormalTok{actors\_yob}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 68 36 56 66 49 62
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mean}\NormalTok{(}\FunctionTok{as.numeric}\NormalTok{(}\FunctionTok{format}\NormalTok{(}\FunctionTok{Sys.Date}\NormalTok{(), }\StringTok{"\%Y"}\NormalTok{)) }\SpecialCharTok{{-}}\NormalTok{ breaking\_bad}\SpecialCharTok{$}\NormalTok{actors\_yob)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 56.16667
\end{verbatim}

We could also subset the data frame using the squared brackets approach
discussed earlier for vectors. Because we are dealing with multiple
vectors simultaneously, we need to indicate the row \emph{and} column
dimensions we want to subset using this format:
\texttt{{[}row,\ column{]}}. So if we want to know what the contents are
of row 4, column 3 (as a sanity check: verify yourself this is the cell
that contains the year of birth of the actor that plays Gus: 1958), we
would do the following:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{breaking\_bad[}\DecValTok{4}\NormalTok{, }\DecValTok{3}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1958
\end{verbatim}

And like vectors, we can also apply ranges (using vectors for the row
and column dimensions):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{breaking\_bad[ }\FunctionTok{c}\NormalTok{(}\DecValTok{4}\SpecialCharTok{:}\DecValTok{6}\NormalTok{), }\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\SpecialCharTok{:}\DecValTok{4}\NormalTok{) ]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   main_character actors_yob sex
## 4            Gus       1958   1
## 5          Lydia       1975   0
## 6          Jimmy       1962   1
\end{verbatim}

Using numeric indices to subset data frames is problematic for both
columns and rows. It is, therefore, rare to see the approach to
subsetting a data frame as sketched in the code chunk above, where rows
and columns are subsetted in one go. For columns, subsetting is easier
when you use variable names. So, although both lines of code in the
chunk below yield the same output, the first one is easier to
understand.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{breaking\_bad}\SpecialCharTok{$}\NormalTok{main\_character}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Walt"   "Todd"   "Skyler" "Gus"    "Lydia"  "Jimmy"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{breaking\_bad[, }\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Walt"   "Todd"   "Skyler" "Gus"    "Lydia"  "Jimmy"
\end{verbatim}

Another reason using numeric indices to subset columns in data frames is
problematic is that sometimes the location of columns in a data frame
might change after applying a function. Hence, using a \texttt{\$}-sign
instead of a numeric index is always advisable. Subsetting rows using
numeric indices is problematic because we often need to know the
specific rows of the value(s) of interest. The fact of the matter is
that often subsetting aims to locate rows! So, in line with the example
provided in the logical chunk, we now follow the approach we followed
when we discussed subsetting vectors using logical constants. Let's say
we want to get those rows in the data frame where the sex of the actor
is male. Following standard practice in dummy coding, this means
filtering for a value of 1 because the m (of male) occurs after the f
(of female) in the alphabet. Below, you'll find one standard way to do
this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{breaking\_bad[ breaking\_bad}\SpecialCharTok{$}\NormalTok{sex }\SpecialCharTok{==} \DecValTok{1}\NormalTok{, ]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    main_character first_occurence actors_yob sex
## NA           <NA>            <NA>         NA  NA
## 2            Todd          S05E03       1988   1
## 4             Gus          S02E11       1958   1
## 6           Jimmy          S92E11       1962   1
\end{verbatim}

Regarding using square brackets, nothing has changed. But, instead of
using numbers, we have created a logical vector that gives either TRUE
or FALSE based on the condition \texttt{breaking\_bad\$sex\ ==\ 1} (try
running this code fragment and see what it yields). This vector, indeed,
gives us all male characters. But something is off: we also see a row
that only contains NAs. This row occurs because of the missing value for
Walt's sex. We could remedy this by embedding the result of our subset
in the \texttt{na.omit()}-function:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{na.omit}\NormalTok{(breaking\_bad[ breaking\_bad}\SpecialCharTok{$}\NormalTok{sex }\SpecialCharTok{==} \DecValTok{1}\NormalTok{, ])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   main_character first_occurence actors_yob sex
## 2           Todd          S05E03       1988   1
## 4            Gus          S02E11       1958   1
## 6          Jimmy          S92E11       1962   1
\end{verbatim}

Using \texttt{na.omit} works. But, it is annoying to remedy an issue
caused by the quirks of a specific function. With the second half of the
statement, `focus on getting done whatever it is you want to get done
\textbf{but} try to keep your code simple', let's see if there is an
alternative way. There is:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{breaking\_bad[ }\FunctionTok{which}\NormalTok{(breaking\_bad}\SpecialCharTok{$}\NormalTok{sex }\SpecialCharTok{\%in\%} \DecValTok{1}\NormalTok{), ]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   main_character first_occurence actors_yob sex
## 2           Todd          S05E03       1988   1
## 4            Gus          S02E11       1958   1
## 6          Jimmy          S92E11       1962   1
\end{verbatim}

Instead of \texttt{==}, which tests if two elements are exactly equal,
we use \texttt{\%in\%}, which looks for matches. You won't notice any
difference when working with complete data (i.e.~data that does
\emph{not} contain missing values). But once NAs get involved, you will
find \texttt{\%in\%} to give the desired result immediately.

Lastly, the \texttt{order} function is helpful to work with within the
context of subsetting. You can use this function to sort a data frame,
for example, if we want to sort the characters in the data frame based
on the \texttt{yob}-variable. When we apply the \texttt{order} function
to this variable, R generates a vector that indicates the location of
the lowest number, the second lowest number, etc. (see the first line in
the chunk below). If we embed that result between square brackets, as we
do when subsetting, the data frame will be reordered automatically (see
the second line):

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{order}\NormalTok{(breaking\_bad}\SpecialCharTok{$}\NormalTok{actors\_yob)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 4 6 3 5 2
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{breaking\_bad[ }\FunctionTok{order}\NormalTok{(breaking\_bad}\SpecialCharTok{$}\NormalTok{actors\_yob), ]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   main_character first_occurence actors_yob sex
## 1           Walt          S01E01       1956  NA
## 4            Gus          S02E11       1958   1
## 6          Jimmy          S92E11       1962   1
## 3         Skyler          S01E01       1968   0
## 5          Lydia          S05E02       1975   0
## 2           Todd          S05E03       1988   1
\end{verbatim}

\hypertarget{concluding-remarks-on-data-frames}{%
\paragraph{Concluding remarks on data
frames}\label{concluding-remarks-on-data-frames}}

Next to vectors, you now know data frames and some useful functions and
operations. There are many other data objects one can encounter in R,
such as matrices (similar to data frames in that they are
multidimensional, but different in that a matrix can only hold data of
one type, just as vectors) and lists (similar to a data frame in that it
can contain data of different types, but different in that lists also
can contain data vectors of various sizes. A data frame in R is a
particular case of a list, but for now, this is not important). In our
experience, however, once you understand the basics of vectors and data
frames, you'll manage to deal with the larger part of data objects that
R might spit out.

We conclude this first tutorial with a small demo of what we can do in
R. Not only will we learn how to import data from a .csv-file, but we'll
also see how to combine variables, join data frames, make simple and
more advanced calculations and heck, we'll even run a naive regression
model and plot it. Don't feel too intimidated by all of this. It is a
demo, and the goal is that in the end, when you run into an issue
somewhere along the way, you might remember that this tutorial contains
a code snippet that you can use directly or after some tweaks to fix
that issue. Ah, and before we forget, let's change Walt's gender from NA
to 1 (see if you can make sense of what happens in the snippet below.
You'll see a similar operation later on):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{breaking\_bad[ }\FunctionTok{which}\NormalTok{(breaking\_bad}\SpecialCharTok{$}\NormalTok{main\_character }\SpecialCharTok{\%in\%} \StringTok{"Walt"}\NormalTok{), ]}\SpecialCharTok{$}\NormalTok{sex }\OtherTok{\textless{}{-}} \DecValTok{1}
\end{Highlighting}
\end{Shaded}

\hypertarget{basic-data-wrangling-activities}{%
\subsubsection{3. Basic data-wrangling
activities}\label{basic-data-wrangling-activities}}

\hypertarget{workspace-management}{%
\paragraph{Workspace management}\label{workspace-management}}

Before starting our demo, let's look at the objects accumulated in our
workspace. We can see this in the upper right of this console (tab
`Environment'), but we could also get an overview by running the
following command:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ls}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "breaking_bad" "i"            "words"        "x"            "y"
\end{verbatim}

The \texttt{ls()} function lists all objects currently living in the R
environment. By now, the \texttt{breaking\_bad} object does not need
further introduction. We created the other objects while explaining
vectors and can safely remove them with the \texttt{remove} function:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{remove}\NormalTok{(i, words, x, y)}
\end{Highlighting}
\end{Shaded}

\hypertarget{load-external-data}{%
\paragraph{Load external data}\label{load-external-data}}

Typically, we don't get data into R by manually entering it, as we have
done so far. Instead, we get our data from external sources. Say, for
example, that we want to expand the information in our breaking\_bad
data frame and include data on the episodes. We included a file named
\texttt{breaking\_bad.csv} in the module on Brightspace. \emph{Ensure
this file is in the same folder from where you loaded this workbook},
and let's load this data. R can open various data file formats
(e.g.~.txt, .xls, .xlsx, .sav, etc.). For some of these formats, you
need to install additional packages (e.g.~the \texttt{rio}-package), but
here we use the built-in \texttt{read.csv} command. We assign the loaded
data to an object called \texttt{episodes} in the code chunk below.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{episodes }\OtherTok{\textless{}{-}} \FunctionTok{read.csv}\NormalTok{(}\StringTok{"breaking\_bad.csv"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

You can get more information about this file from
\href{https://www.kaggle.com/datasets/varpit94/breaking-bad-tv-show-all-seasons-episodes-data?resource=download}{Kaggle},
where we downloaded it. Let's explore the structure of this newly
created object:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{str}\NormalTok{(episodes)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 'data.frame':    62 obs. of  10 variables:
##  $ Date                : chr  "20-Jan-08" "27-Jan-08" "10-Feb-08" "17-Feb-08" ...
##  $ Season              : int  1 1 1 1 1 1 1 2 2 2 ...
##  $ Episode             : int  1 2 3 4 5 6 7 1 2 3 ...
##  $ Title               : chr  "Pilot" "Cat's in the Bag..." "...And the Bag's in the River" "Cancer Man" ...
##  $ Directed.by         : chr  "Vince Gilligan" "Adam Bernstein" "Adam Bernstein" "Jim McKay" ...
##  $ Written.by          : chr  "Vince Gilligan" "Vince Gilligan" "Vince Gilligan" "Vince Gilligan" ...
##  $ Duration_mins       : int  58 48 48 48 48 48 48 47 46 47 ...
##  $ Summary             : chr  "Diagnosed with terminal lung cancer, chemistry teacher Walter White teams up with former student Jesse Pinkman "| __truncated__ "After their first drug deal goes terribly wrong, Walt and Jesse are forced to deal with a corpse and a prisoner"| __truncated__ "Walt and Jesse clean up after the bathtub incident before Walt decides what course of action to take with their"| __truncated__ "Walt tells the rest of his family about his cancer. Jesse tries to make amends with his own parents." ...
##  $ Rating_IMDB         : num  9.1 8.7 8.8 8.3 8.4 9.3 8.9 8.7 9.3 8.4 ...
##  $ U.S..viewers_million: chr  "1.41" "1.49" "1.08" "1.09" ...
\end{verbatim}

Earlier, we introduced the \texttt{head} function for exploring data and
explained that this function would only sometimes yield an insightful
output. See if you agree with us by applying it to the \texttt{episodes}
data in the chunk above!

\hypertarget{combining-data---preparation}{%
\paragraph{Combining data -
preparation}\label{combining-data---preparation}}

Let's say we want to add data available in the \texttt{episodes} data
frame to our breaking\_bad data frame. For this to work, we need to have
one or more overlapping variables to link both frames. Luckily, these
are present in the form of the season and episode data (we use the
\texttt{cbind} function to combine (``bind'') columns (hence the c).
Specifying column names is optional but advisable):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{breaking\_bad}\SpecialCharTok{$}\NormalTok{first\_occurence}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "S01E01" "S05E03" "S01E01" "S02E11" "S05E02" "S92E11"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{head}\NormalTok{(}\FunctionTok{cbind}\NormalTok{(}\AttributeTok{Season =}\NormalTok{ episodes}\SpecialCharTok{$}\NormalTok{Season, }\AttributeTok{Episode =}\NormalTok{ episodes}\SpecialCharTok{$}\NormalTok{Episode))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      Season Episode
## [1,]      1       1
## [2,]      1       2
## [3,]      1       3
## [4,]      1       4
## [5,]      1       5
## [6,]      1       6
\end{verbatim}

Before proceeding, however, we need to do some harmonisation work.
Whereas in the \texttt{breaking\_bad} data frame, one variable
(\texttt{first\_occurence}) captures the season/episode information, the
\texttt{episodes} data frame neatly displays them in two columns. We
need to change the variable(s) in one of the data frames so that the
resulting format matches the variable(s) format in the other. The
attractive way is to manually do this for the breaking\_bad data frame,
as it only contains six observations. But it could be more scalable:
what if we had a table with the entire cast of 400+ individuals? So:
good idea, but no. Instead, let's see what functionality R offers to do
this programmatically. One way would be combining the \texttt{paste}
function and the \texttt{sprintf} function available in R and applying
them to the episodes data frame. The \texttt{paste} function puts
whatever it gets fed (e.g.~the contents of a vector) into one character
vector:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{paste}\NormalTok{(}\StringTok{"R"}\NormalTok{, }\StringTok{"is"}\NormalTok{, }\StringTok{"awesome"}\NormalTok{, }\AttributeTok{sep =} \StringTok{" "}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "R is awesome"
\end{verbatim}

The \texttt{sprintf} function does something similar but allows for a
bit more formatting. In the example below, we want to generate a number
sequence that consists of at least two digits:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sprintf}\NormalTok{(}\StringTok{"\%02d"}\NormalTok{, }\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{100}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "01"  "10"  "100"
\end{verbatim}

If we combine both, we get the below. Note comments, indentation and the
use of multiple lines to maintain readability:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{episodes}\SpecialCharTok{$}\NormalTok{season\_episode }\OtherTok{\textless{}{-}} \FunctionTok{paste}\NormalTok{(}\StringTok{"S"}\NormalTok{, }\CommentTok{\# first letter denotes season}
                                 \FunctionTok{sprintf}\NormalTok{(}\StringTok{"\%02d"}\NormalTok{, }\FunctionTok{as.numeric}\NormalTok{(episodes}\SpecialCharTok{$}\NormalTok{Season)), }\CommentTok{\# season no.}
                                 \StringTok{"E"}\NormalTok{, }\CommentTok{\# second letter denotes episode}
                                 \FunctionTok{sprintf}\NormalTok{(}\StringTok{"\%02d"}\NormalTok{, }\FunctionTok{as.numeric}\NormalTok{(episodes}\SpecialCharTok{$}\NormalTok{Episode)), }\CommentTok{\# episode no.}
                                 \AttributeTok{sep =} \StringTok{""}\NormalTok{) }\CommentTok{\# do not separated components}
\end{Highlighting}
\end{Shaded}

In the function call above, we create a new variable
\texttt{season\_episode} and add it to the \texttt{episodes} data frame
on the fly: another perk of working with the dollar sign! So now we got
what we want. Again, this is one way to do it. It is possible to
criticise this approach because we create a `non-tidy' variable,
i.e.~one variable that contains multiple information components (both
season and episode information). So a better way would be to split the
\texttt{first\_occurence}-variable in the \texttt{breaking\_bad} data
frame using functions that, instead of combining two variables, split
one variable into two. If that resonates with you, challenge your
lecturer the next time you see him and ask for a live demo of how to do
this during the lecture. The end justifies the means for now, and we
proceed with what we have created.

\hypertarget{combining-data---the-actual-merge}{%
\paragraph{Combining data - the actual
merge}\label{combining-data---the-actual-merge}}

Now we are ready to combine both data frames. If you work with
databases, you know that there are multiple ways of merging data frames.
Let's say \texttt{breaking\_bad} is left, and \texttt{episodes} is
right. We then can define the following merges:

\begin{itemize}
\item
  Left join: retain all rows in \texttt{breaking\_bad} and add
  information from \texttt{episodes} for those elements
  (i.e.~season/episode combinations) present in both data frames;
\item
  Right join retain all rows in \texttt{episodes} and add information
  from \texttt{breaking\_bad} for those elements present in both data
  frames;
\item
  Full join: combine and retain all information;
\item
  Inner join: combine and retain information from \texttt{breaking\_bad}
  and \texttt{episodes} for those elements present in both data frames.
\end{itemize}

We want to add data available in the \texttt{episodes} data frame to the
\texttt{breaking\_bad} data frame, so we want to perform a left join. We
do this in R as follows:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{merge}\NormalTok{(breaking\_bad, episodes, }
      \AttributeTok{by.x =} \StringTok{"first\_occurence"}\NormalTok{, }\CommentTok{\# x is left (breaking\_bad)}
      \AttributeTok{by.y =} \StringTok{"season\_episode"}\NormalTok{, }\CommentTok{\# y is right (episodes)}
      \AttributeTok{all.x =} \ConstantTok{TRUE}\NormalTok{) }\CommentTok{\# all.y = right join, all = full join, leave out for inner join}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   first_occurence main_character actors_yob sex      Date Season Episode
## 1          S01E01           Walt       1956   1 20-Jan-08      1       1
## 2          S01E01         Skyler       1968   0 20-Jan-08      1       1
## 3          S02E11            Gus       1958   1 17-May-09      2      11
## 4          S05E02          Lydia       1975   0 22-Jul-12      5       2
## 5          S05E03           Todd       1988   1 29-Jul-12      5       3
## 6          S92E11          Jimmy       1962   1      <NA>     NA      NA
##        Title       Directed.by                     Written.by Duration_mins
## 1      Pilot    Vince Gilligan                 Vince Gilligan            58
## 2      Pilot    Vince Gilligan                 Vince Gilligan            58
## 3    Mandala    Adam Bernstein Vince Gilligan, George Mastras            47
## 4   Madrigal Michelle MacLaren                 Vince Gilligan            48
## 5 Hazard Pay    Adam Bernstein    Vince Gilligan, Peter Gould            48
## 6       <NA>              <NA>                           <NA>            NA
##                                                                                                                                         Summary
## 1 Diagnosed with terminal lung cancer, chemistry teacher Walter White teams up with former student Jesse Pinkman to cook and sell crystal meth.
## 2 Diagnosed with terminal lung cancer, chemistry teacher Walter White teams up with former student Jesse Pinkman to cook and sell crystal meth.
## 3                                    Walt and Jesse's little empire begins to crumble. Saul tries to set them up with a mysterious distributor.
## 4                    Walt and Jesse seek out an unlikely partner for a new business venture. The DEA follows up new leads in its investigation.
## 5                                                                            The guys put a business plan into action; Walt confesses to Marie.
## 6                                                                                                                                          <NA>
##   Rating_IMDB U.S..viewers_million
## 1         9.1                 1.41
## 2         9.1                 1.41
## 3         8.9                  N/A
## 4         8.9                 2.29
## 5         8.9                  2.2
## 6          NA                 <NA>
\end{verbatim}

And there it is! Did we say earlier that some functions might change the
order of columns? The \texttt{merge} function is one of them: the column
in the `left' data frame used to combine both data frames is now the
first. Another point for the dollar sign team!

But wait, what's with all the NA values in the last row? We made a data
entry error when adding the episode information for Jimmy in the data
frame: we mistook a 9 for a 0, resulting in S92E11 instead of S02E11.
Once again: perform sanity checks by inspecting your data whenever you
can. As in life, making mistakes is okay, but not solving them when you
see them is not. So, let's correct that error. We then also merge the
data frames again and overwrite the breaking\_bad data frame:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{breaking\_bad[ }\FunctionTok{which}\NormalTok{(breaking\_bad}\SpecialCharTok{$}\NormalTok{main\_character }\SpecialCharTok{\%in\%} \StringTok{"Jimmy"}\NormalTok{), ]}\SpecialCharTok{$}\NormalTok{first\_occurence }\OtherTok{\textless{}{-}} \StringTok{"S02E11"}
\NormalTok{breaking\_bad }\OtherTok{\textless{}{-}} \FunctionTok{merge}\NormalTok{(breaking\_bad, episodes, }
      \AttributeTok{by.x =} \StringTok{"first\_occurence"}\NormalTok{,}
      \AttributeTok{by.y =} \StringTok{"season\_episode"}\NormalTok{,}
      \AttributeTok{all.x =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Now that we have our expanded data frame let's explore it. What is, for
example, the average IMDB rating of an episode if we differentiate by
sex? We can use the \texttt{aggregate} function for this:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{aggregate}\NormalTok{(breaking\_bad}\SpecialCharTok{$}\NormalTok{Rating\_IMDB,}
          \AttributeTok{by =} \FunctionTok{list}\NormalTok{(}\StringTok{"sex"} \OtherTok{=}\NormalTok{ breaking\_bad}\SpecialCharTok{$}\NormalTok{sex),}
          \AttributeTok{FUN =}\NormalTok{ mean)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   sex    x
## 1   0 9.00
## 2   1 8.95
\end{verbatim}

The input to the aggregate function looks messy. It takes a variable
(the first line in the code above) and groups it by another variable
(the second line above). For some reason, this function only takes lists
as input, making the code look a bit bombastic here). Then, it applies a
function to both subsets of the data (\texttt{mean} in this example, but
the options are legion).

Lastly, let's estimate a regression model and map this model to the
data. As a general rule, one should \emph{never} even flirt with the
idea of applying a regression model to a data set with only six
observations (and don't even get us started about the multi-level
structure we introduced when we merged data on characters with data on
episodes) but for the sake of example, let's see what happens if we
predict episode duration with the age of an actor. Could older actors
have less stamina, resulting in shorter episode durations when featuring
in an episode? Let's create the age variable and run the model:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{breaking\_bad}\SpecialCharTok{$}\NormalTok{age }\OtherTok{\textless{}{-}}\NormalTok{ (}\FunctionTok{as.numeric}\NormalTok{(}\FunctionTok{format}\NormalTok{(}\FunctionTok{Sys.Date}\NormalTok{(), }\StringTok{"\%Y"}\NormalTok{)) }\SpecialCharTok{{-}}\NormalTok{ breaking\_bad}\SpecialCharTok{$}\NormalTok{actors\_yob) }\CommentTok{\# create the age variable}
\NormalTok{lm }\OtherTok{\textless{}{-}} \FunctionTok{lm}\NormalTok{(breaking\_bad}\SpecialCharTok{$}\NormalTok{Duration\_mins }\SpecialCharTok{\textasciitilde{}}\NormalTok{ breaking\_bad}\SpecialCharTok{$}\NormalTok{age) }\CommentTok{\# estimating the linear (regression) model (lm)}
\FunctionTok{summary}\NormalTok{(lm) }\CommentTok{\# look at the model results}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
## Call:
## lm(formula = breaking_bad$Duration_mins ~ breaking_bad$age)
## 
## Residuals:
##       1       2       3       4       5       6 
##  5.3602  7.0231 -5.3627 -4.8084 -2.0069 -0.2054 
## 
## Coefficients:
##                  Estimate Std. Error t value Pr(>|t|)  
## (Intercept)       43.2166    12.2715   3.522   0.0244 *
## breaking_bad$age   0.1386     0.2144   0.646   0.5533  
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## Residual standard error: 5.788 on 4 degrees of freedom
## Multiple R-squared:  0.09457,    Adjusted R-squared:  -0.1318 
## F-statistic: 0.4178 on 1 and 4 DF,  p-value: 0.5533
\end{verbatim}

The part in the table above that we are especially interested in is the
information about \texttt{breaking\_bad\$age}: its coefficient (0.1386)
is \emph{not} significant (Pr(\textgreater\textbar t\textbar) is a
factor ten larger than the typical academic threshold of 0.05), so we
reject the alternative hypothesis (a negative relationship exists
between the age of an actor and episode duration). We retain the null
hypothesis (\textbf{no} association exists between the age of an actor
and episode duration). Let's visualise this model, nevertheless, to see
how we could embed the results of the \texttt{lm()} function in a
plotting command. To achieve this, we first build a plot (see the
\texttt{plot()} function) and then add the regression model (see the
\texttt{abline} function):

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{plot}\NormalTok{(breaking\_bad}\SpecialCharTok{$}\NormalTok{age, breaking\_bad}\SpecialCharTok{$}\NormalTok{Duration\_mins,}
     \AttributeTok{xlab =} \StringTok{"Actors age"}\NormalTok{,}
     \AttributeTok{ylab =} \StringTok{"Episode duration"}\NormalTok{,}
     \AttributeTok{pch =} \DecValTok{4}\NormalTok{) }\CommentTok{\# different plot character (value can range between 0 and 25)}

\FunctionTok{abline}\NormalTok{(lm, }\CommentTok{\# adding the regression line}
       \AttributeTok{lty =} \DecValTok{5}\NormalTok{, }\CommentTok{\# specifying line type (ranges from 0 to 6)}
       \AttributeTok{lwd =} \DecValTok{2}\NormalTok{, }\CommentTok{\# specifying line width (default = 1)}
       \AttributeTok{col =} \StringTok{"blue"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{Introduction-to-R_files/figure-latex/plot-1.pdf}

Although the line above suggests a relation (actually one opposite to
the hypothesis we formulated), please don't get fooled by it. R
truncated both axes, which is especially problematic for the y-axis:
this axis does \textbf{not} start at 0 but at 47. We can learn from the
graph above that R's graphing capabilities are flexible. They are so
extensive we could easily dedicate a separate workbook to them! For now,
however, we want you to see how you can do this, so you are already
acquainted with it when you see this happening in future workbooks.

\hypertarget{concluding-remarks}{%
\subsubsection{Concluding remarks}\label{concluding-remarks}}

You have reached the end of this workbook. We hope you enjoyed it! The
contents we covered should be enough to get you started. If you want to
convert this file to a .html-file, click the `Knit'- button above. You
need to knit your document into a PDF or Word document for the
assignment. Note that RStudio does \textbf{not} build these documents
from scratch. Instead, you will need to have a Latex distribution
installed on your machine to make PDFs
(e.g.~(MiKTeX){[}\url{https://miktex.org}{]}) (when using Windows) or
(MacTeX){[}\url{https://tug.org/mactex/}{]} (when using MacOS) or Word
to make Word files. LaTeX distributions, however, are relatively
sizeable. An alternative strategy could be to Knit your document to Word
and print it to pdf from there. The benefit of this approach is that,
following that strategy, you can also do some in-between editing work,
perform a spelling and grammar check, and change the layout to your
taste (not everyone likes the standard, `LaTeX'-y look and touch, which
we fully understand). In the end, how to approach this is up to you. If
you want to quit R and close RStudio, type \texttt{quit()} in the
console below.

\hypertarget{further-reading}{%
\subsubsection{Further reading}\label{further-reading}}

If you developed an appetite for more, below are some references we
think are valuable (our comments in brackets after each suggestion).

\hypertarget{books}{%
\paragraph{Books}\label{books}}

\begin{itemize}
\tightlist
\item
  Cotton, R. (2013). Learning R. Sebastopol, CA: O'Reilly Media,
  Inc.~(the basic building blocks)
\item
  Kabacoff, R. I. (2011). R in Action - Data analysis and graphics with
  R. Shelter Island, NY: Manning Publications Co.~(application-driven
  basics)
\item
  Wickham, H., \& Grolemund, G. (2017). R for Data Science. Sebastopol,
  CA: O'Reilly Media, Inc.~(tidy-verse based, written by the master
  himself. Focuses on the analytics workflow)
\end{itemize}

\hypertarget{websites}{%
\paragraph{Websites}\label{websites}}

\begin{itemize}
\tightlist
\item
  \url{https://www.statmethods.net} (complements the Kabacoff-book)
\item
  \url{https://www.r-bloggers.com} (compiles how-to's in R submitted by
  enthusiasts)
\item
  \url{https://stats.stackexchange.com} (forum, focus on statistics)
\item
  \url{https://stackoverflow.com} (forum, focus on programming)
\item
  \url{http://adv-r.had.co.nz/Style.html} (coding style suggestions)
\end{itemize}

\end{document}
